# ==> backup-history <==
#!/bin/zsh

_backitup() {
    TS=$(timestamp)
    e "\${TS} = ${TS}"

    ecko "tarc" 88 188
    tar -czvf "${TMP}/histfile_${TS}.tar.gz" -C "$(dirname ${HISTFILE})" "$(filename ${HISTFILE})"
    ecko "ls -lah ${TMP}/histfile_${TS}.tar.gz" 188 18
    ls -lah  "${TMP}/histfile_${TS}.tar.gz"
    ecko "ls -lah ${HISTFILE}" 188 88
    ls -lah "${HISTFILE}"

    ecko "mv ${HISTFILE} ${TMPDIR}/zsh_history-${TS}.txt" 188 88
    mv "${HISTFILE}" "${TMPDIR}/zsh_history-${TS}.txt"
    ecko "ls -lah ${TMPDIR}/zsh_history-${TS}.txt" 188 88
    ls -lah "${TMPDIR}/zsh_history-${TS}.txt"
    ecko "cat ${TMPDIR}/zsh_history-${TS}.txt | tail -n 100 > ${HISTFILE}" 188 88
    cat "${TMPDIR}/zsh_history-${TS}.txt" | tail -n 100 > "${HISTFILE}"
    ecko "ls -lah ${HISTFILE}" 188 88
    ls -lah "${HISTFILE}"

}

_backup-history () {
    WCL=$(cat ${HISTFILE} | wc -l)
    ecko "WCL ${WCL}" 88 188
    ecko "HISTFILE ${HISTFILE}" 88 188

    [[ ${WCL} -lt 3500 ]] || _backitup
}


# ==> deduplicate-bash-history <==

# keep only the first occurrence of each duplicate entry in ~/.bash_history
#
# 1. Break records at points matching a timestap. Special case
# for the first and last lines in the history file (setting RS to a regexp is a
# GNU awk extension). This way the script matches multi-line commands in the file
# 2. Set the timestamp of the current record to the previous record separator,
# trim starting line break
# 3. Skip empty lines (e.g. the one produced while processing the first line)

_deduplicate-bash-history() {
    out=$(mktemp)
    gawk -vRS='(^|\n)#[0-9]+\n' \
        '{
            sub(/\n$/, "")
            if (${0} && cmds[${0}]++ == 0)
                print time ${0}
            time = RT
            sub(/^\n/, "", time)
        }' < ~/.bash_history > ${out}
    mv ${out} ~/.bash_history

}

# ==> hist2hist <==



_hist2hist () {
	for i in $(cat "${1}")
	do
		TS=$(e ${i} | grep -oE '[0-9]{10}')
		(
			[[ ${#TS} -eq 0 ]] || isNumber "1669747077"
			[[ "${?}" -eq 0 ]] && echo "${_TU1}" || echo "${_TD1}" ${TS}
		) && continue
		echo "$(date -r ${TS}) ${i[15,-1]}" >> "${1}.txt"
	done
}


# ==> histfile <==



_histfile () {
	omz_history -E | original less
}


# ==> history-alt <==


source ${SHELL_VARS_REGEX}

_history-alt () {
	IFS_PREV+=${IFS}
	IFS=${DELIMITER_ENDL}
	for line in $(cat "${1}")
	do
		TMPDATE="$(echo ${line} | list-col -d ':' 2 | timestamp2date)"
		echo -n "${TMPDATE} "
		echo ${line} | sed -E "s/${REGEX_HISTFILE_TIMESTAMP}//g"
	done
}


# ==> history-extract-old-tars2tmpdir <==



_history-extract-old-tars2tmpdir () {
	mkdir -p ${TMPDIR}/all-histfiles
    CNTR=1
	for targz in $(ls -1Ut ${TMP}/*(HIST|hist)*.tar.gz)
	do
		echo ${targz}
        tar -xzvf ${targz} -s /\.\*zsh_history/zsh_history$(timestamp)-${CNTR}/g --directory ${TMPDIR}/all-histfiles/
        ((CNTR++))
	done
}


# ==> list-histfiles <==



_list-histfiles () {
	# ls -1Ut ${@} ${TMP}/histfile_*.txt
	ls -1Ut ${@} ${TMP}/*histfile* | grep -vE ".*.gz"
}


# ==> remove-from-history <==

_remove-from-history() {
    source ${SHELL_FUNCTIONS}
    source ${SHELL_VARS}
    SCRIPTNAME=$(dirname ${0})
    echo "\${SCRIPTNAME} = ${SCRIPTNAME}"


    cp ${HISTFILE} ${TMP}/histfile_$(date +%s)

    remove-from ${HISTFILE} "${1}"

    remove-from ${HISTFILE} ${SCRIPTNAME}
}

# ==> set-pwd-histfile <==
export HISTFILE_PREV=${HISTFILE}
export HISTFILE=${ZDOTDIR}/$(filename ${PWD})_history

reset-historyfile() {
	export HISTFILE=${HISTFILE_PREV}
}
